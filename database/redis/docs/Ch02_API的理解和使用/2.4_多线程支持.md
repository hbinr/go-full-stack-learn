# 多线程支持

## 一.历史原因分析

众所周知，Redis 之前的版本一直都是典型的单线程模型（注意：这里不是指 Redis 单实例中只有一个线程，而是表示 核心操作模块由单线程完成，当然另外还有一些 辅助线程 从旁协助，比如 LRU 的淘汰过程），为什么不使用多线程呢，其实原因很简单（官方解释）：

![2.7 单线程原因](../../img/图%202-7%20单线程原因.jpg)

简单说来就是：

- 根据以往的场景，普通 KV 存储 瓶颈压根不在 CPU，而往往可能受到 内存 和 网络 I/O 的制约
- Redis 中有各种类型的数据操作，甚至包括一些事务处理，如果采用多线程，则会被多线程产生的切换问题而困扰，也可能因为加锁导致系统架构变的异常复杂，更有可能会因为加锁解锁甚至死锁造成的性能损耗

当然，单线程也会有 **不能充分利用多核资源** 弊端，这是一个权衡；而通常 Redis（包括 Redis cluster） 的性能已经足够我们使用。

那么，既然 单线程 都已经基本能满足场景，更不要说还能开启 多实例、上集群 等方式，那么为什么还要费力引入 多线程呢？

## 二.引入多线程

因为读写网络的 read/write 系统调用在 Redis 执行期间占用了大部分 CPU 时间，如果把网络读写做成多线程的方式对性能会有很大提升。

**Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程**。之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。

Redis 在最新的几个版本中加入了一些可以被其他线程异步处理的删除操作。

我们为什么会需要这些删除操作，而它们为什么需要通过多线程的方式异步处理？

我们知道 Redis 可以使用 del 命令删除一个元素，如果这个元素非常大，可能占据了几十兆或者是几百兆，那么在短时间内是不能完成的，这样一来就需要多线程的异步支持。

现在删除工作可以在后台进行。

## 三.总结

Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；

而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。
