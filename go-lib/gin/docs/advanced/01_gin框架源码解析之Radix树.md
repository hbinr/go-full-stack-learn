# Gin 框架源码解析之 Radix 树

gin 框架使用的是定制版本的 httprouter，其路由的原理是大量使用公共前缀的树结构，它基本上是一个紧凑的 [Trie tree](https://baike.sogou.com/v66237892.htm)（或者只是 [Radix Tree](https://baike.sogou.com/v73626121.htm)）。具有公共前缀的节点也共享一个公共父节点。

### Radix Tree

基数树（Radix Tree）又称为 PAT 位树（Patricia Trie or crit bit tree），是一种更节省空间的前缀树（Trie Tree）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。下图为一个基数树示例：

![](https://www.liwenzhou.com/images/Go/gin/radix_tree.png)

Radix Tree 可以被认为是一棵简洁版的前缀树。我们注册路由的过程就是构造前缀树的过程，具有公共前缀的节点也共享一个公共父节点。假设我们现在注册有以下路由信息：

```go
r := gin.Default()

r.GET("/", func1)
r.GET("/search/", func2)
r.GET("/support/", func3)
r.GET("/blog/", func4)
r.GET("/blog/:post/", func5)
r.GET("/about-us/", func6)
r.GET("/about-us/team/", func7)
r.GET("/contact/", func8)
```

那么我们会得到一个 GET 方法对应的路由树，具体结构如下：

```
Priority   Path             Handle
9          \                *<1>
3          ├s               nil
2          |├earch\         *<2>
1          |└upport\        *<3>
2          ├blog\           *<4>
1          |    └:post      nil
1          |         └\     *<5>
2          ├about-us\       *<6>
1          |        └team\  *<7>
1          └contact\        *<8>

```

上面最右边那一列每个`*<数字>`表示 Handle 处理函数的内存地址(一个指针)。从根节点遍历到叶子节点我们就能得到完整的路由表。

例如：`blog/:post` 其中`:post` 只是实际文章名称的占位符(参数)。与 hash-maps 不同，这种树结构还允许我们使用像`:post` 参数这种动态部分，因为我们实际上是根据路由模式进行匹配，而不仅仅是比较哈希值。

**gin 的路由为什么不用哈希或者链表来实现？**

因为网站的路径通常都是比较短、有限的，26 个字母加一些常用的符号就能表示绝大多数实际应用的 URL 了。

虽然使用哈希和链表来匹配路由的时间复杂度为 O(1)，非常快了，但是使用基数树结构匹配路由的速度也不比其差多少，相比之下并不会对性能有多大的影响。

URL 路径是具有层次结构的，并且只使用有限的一组字符(字节值)，所以很可能有许多常见的前缀。这使我们可以很容易地将路由简化为更小的问题。此外，**路由器为每个请求方法(如 GET、POST 等)管理一棵单独的树**。一方面，它比在每个节点中都保存一个 method-> handle map 更加节省空间，它还使我们甚至可以在开始在前缀树中查找之前大大减少路由问题。

为了获得更好的可伸缩性，每个树级别上的子节点都按 `Priority(优先级)`排序，其中优先级（最左列）就是在子节点(子节点、子子节点等等)中注册的句柄的数量。这样做有两个好处:

- 首先优先匹配被大多数路由路径包含的节点。这样可以让尽可能多的路由快速被定位。
- 类似于成本补偿。最长的路径可以被优先匹配，补偿体现在最长的路径需要花费更长的时间来定位，如果最长路径的节点能被优先匹配（即每次拿子节点都命中），那么路由匹配所花的时间不一定比短路径的路由长。下面展示了节点（每个-可以看做一个节点）匹配的路径：从左到右，从上到下。

```
   ├------------
   ├---------
   ├-----
   ├----
   ├--
   ├--
   └-

```

**如何理解优先级，成本补偿？**

最长的路径优先被匹配，这样在匹配长路由的时候不会花费较长时间。如果是以最短路径开始匹配，那么最长路径的路由会花费较长时间(不断遍历的过程)，这就造成了一个问题：极端长度的路由匹配时间会相差很大，即“短的更短，长的更长”。

如果使用 Priority(优先级)策略，这样就能保证尽可能多的路由快速被定位，太长的路由匹配不会花费过多的时间，太短的路由也不会过短时间就被匹配到，类似于成本补偿。

参考：
https://study.163.com/course/courseMain.htm?courseId=1210171207&share=1&shareId=1015784011

https://www.liwenzhou.com/posts/Go/read_gin_sourcecode/
