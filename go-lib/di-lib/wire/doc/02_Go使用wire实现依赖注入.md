## What is `wire`?
`wire`是google开源的依赖注入框架。或者引用官方的话来说：“`Wire` is a code generation tool that automates connecting components using dependency injection.”。

官方地址：https://github.com/google/`wire`

## Why `wire`?
除了`wire`，Go的依赖注入框架还有Uber的[dig](https://github.com/uber-go/dig)和Facebook的[inject](https://github.com/facebookarchive/inject)，它们都是使用反射机制来实现运行时依赖注入(`runtime dependency injection`)，而`wire`则是采用代码生成的方式来达到编译时依赖注入(`compile-time dependency injection`)。使用反射带来的性能损失倒是其次，更重要的是反射使得代码难以追踪和调试（反射会令Ctrl+左键失效…）。而`wire`生成的代码是符合程序员常规使用习惯的代码，十分容易理解和调试。

关于`wire`的优点，在官方博文上有更详细的的介绍：blog.golang.org/`wire`

## Provider & Injector
provider和injector是wire的两个核心概念。

> provider: a function that can produce a value. These functions are ordinary Go code.
injector: a function that calls providers in dependency order. With Wire, you write the injector’s signature, then Wire generates the function’s body.

通过提供`provider`函数，让`wire`知道如何产生这些依赖对象。`wire`根据我们定义的`injector`函数签名，生成完整的`injector`函数，`injector`函数是最终我们需要的函数，它将按依赖顺序调用`provider`。
### provider
`provider`就是普通的Go函数，可以把它看作是某对象的构造函数，我们通过`provider`告诉wire该对象的依赖情况：
```go
type UserStore struct{}

// NewUserStore *UserStore的provider，表明*UserStore依赖于*Config和 *mysql.DB.
func NewUserStore(cfg *Config, db *mysql.DB) (*UserStore, error) {...}

// NewDefaultConfig *Config的provider，没有依赖
func NewDefaultConfig() *Config {...}

// NewDB是*mysql.DB的provider，依赖于ConnectionInfo
func NewDB(info ConnectionInfo) (*mysql.DB, error) {...}
 
// UserStoreSet 可选项，可以使用wire.NewSet将通常会一起使用的依赖组合起来。
var UserStoreSet = wire.NewSet(NewUserStore, NewDefaultConfig)
```

### injector
`injector`是`wire`生成的函数，我们通过调用`injector`来获取我们所需的对象或值，`injector`会按照依赖关系，按顺序调用`provider`函数，以下为通过wire工具生成的代码：
```go
// File: wire_gen.go
// Code generated by Wire. DO NOT EDIT.
//go:generate wire
//+build !wireinject

// InitUserStore 是由wire生成的injector
func InitUserStore(info ConnectionInfo) (*UserStore, error) {
    // *Config的provider函数
    defaultConfig := NewDefaultConfig()
    // *mysql.DB的provider函数
    db, err := NewDB(info)
    if err != nil {
        return nil, err
    }
    // *UserStore的provider函数
    userStore, err := NewUserStore(defaultConfig, db)
    if err != nil {
        return nil, err
    }
    return userStore, nil
}
```
wire有两个基础概念，`Provider`（构造器）和`Injector`（注入器）。`Provider`实际上就是创建函数，大家意会一下。我们上面`InitUserStore`就是`Injector`。每个注入器实际上就是一个对象的创建和初始化函数。在这个函数中，我们只需要告诉wire要创建什么类型的对象，这个类型的依赖，wire工具会为我们生成一个函数完成对象的创建和初始化工作。



`injector`帮我们把按顺序初始化依赖的步骤给做了，我们在`main.go`中只需要调用`InitUserStore`方法就能得到我们想要的对象了。

那么`wire`是怎么知道如何生成`injector`的呢？我们需要写一个函数来告诉它：

- 定义`injector`的函数签名
- 在函数中使用`wire.Build`方法列举生成`injector`所需的provider
  
例如：
```go
// InitUserStore 用于声明injector的函数签名
func InitUserStore(info ConnectionInfo) (*UserStore, error) {  
    // wire.Build声明要获取一个UserStore需要调用到哪些provider函数
    wire.Build(UserStoreSet, NewDB)
    return nil, nil  // 这些返回值wire并不关心。
}
```
有了上面的函数，wire就可以得知如何生成injector了。wire生成injector的步骤描述如下：

1. 确定所生成injector函数的函数签名：`func InitUserStore(info ConnectionInfo) (*UserStore, error)`
2. 感知返回值第一个参数是`*UserStore`
3. 检查wire.Build列表，找到`*UserStore`的`provider：NewUserStore`
4. 由函数签名`func NewUserStore(cfg *Config, db *mysql.DB)`得知`NewUserStore`依赖于`*Config`, 和`*mysql.DB`
5. 检查wire.Build列表，找到`*Config`和`*mysql.DB`的`provider：NewDefaultConfig`和`NewDB`
6. 由函数签名`func NewDefaultConfig() *Config`得知`*Config`没有其他依赖了。
7. 由函数签名`func NewDB(info *ConnectionInfo) (*mysql.DB, error)`得知`*mysql.DB`依赖于`ConnectionInfo`。
8. 检查wire.Build列表，找不到`ConnectionInfo`的`provider`，但在injector函数签名中发现匹配的入参类型，直接使用该参数作为NewDB的入参。
9. 感知返回值第二个参数是error
10. …
11. 按依赖关系，按顺序调用provider函数，拼装injector函数。

## 最佳实践

### Installing 
```go
$ go get github.com/google/wire/cmd/wire
```
### Quick Start
[示例代码](https://github.com/DrmagicE/wire-examples/tree/master/quickstart)
我们先通过一个简单的例子，让小伙伴们对`wire`有一个直观的认识。下面的例子展示了一个简易`wire`依赖注入示例：

示例核心逻辑就是：向别人打招呼，简单说句话
```go
$ ls
main.go  wire.go 
```
#### main.go
```go
package main

import "fmt"

type Message struct {
	msg string
}
type Greeter struct {
	Message Message
}
type Event struct {
	Greeter Greeter
}
// NewMessage Message的构造函数
func NewMessage(msg string) Message {
	return Message{
		msg:msg,
	}
}
// NewGreeter Greeter构造函数
func NewGreeter(m Message) Greeter {
	return Greeter{Message: m}
}
// NewEvent Event构造函数
func NewEvent(g Greeter) Event {
	return Event{Greeter: g}
}
func (e Event) Start() {
	msg := e.Greeter.Greet()
	fmt.Println(msg)
}
func (g Greeter) Greet() Message {
	return g.Message
}

// 使用wire前
func main() {
	message := NewMessage("hello world")
	greeter := NewGreeter(message)
	event := NewEvent(greeter)

	event.Start()
}

```
#### wire.go
现在我们要使用`wire`了，创建一个 `wire.go`文件
```go
// +build wireinject
// The build tag makes sure the stub is not built in the final build.

package main

import "github.com/google/wire"

// InitializeEvent 声明injector的函数签名
func InitializeEvent(msg string) Event{
	wire.Build(NewEvent, NewGreeter, NewMessage)
	return Event{}  //返回值没有实际意义，只需符合函数签名即可
}
```
为了方便，就和`main.go`目录同级了，这样在调用 `NewXXX`这些函数时不用导入包了。正常开发可以根据自身需求放置 `wire.go`

`cd`到 `wire.go`所在目录，调用`wire`命令生成依赖文件：
```sh
$ wire
wire: github.com/DrmagicE/wire-examples/quickstart: wrote XXXX\github.com\DrmagicE\wire-examples\quickstart\wire_gen.go
$ ls
main.go  wire.go  wire_gen.go
```
注意，如果你运行时，出现了InitializeEvent重定义，那么检查一下你的`//+build wireinject`与`package main`这两行之间是否有空行，这个空行必须要有！见 https://github.com/google/wire/issues/117。

#### wire生成的文件: wire_gen.go
```go
// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

// Injectors from wire.go:

func InitializeEvent(msg string) Event {
	message := NewMessage(msg)
	greeter := NewGreeter(message)
	event := NewEvent(greeter)
	return event
}
```
这个`InitializeEvent()`函数是不是和我们在`main.go`中编写的代码一毛一样！

另外你可能观察到了，`wire.go`和`wire_gen.go`文件头部位置都有一个`+build`，不过一个后面是`wireinject`，另一个是`!wireinject`。`+build`其实是 Go 语言的一个特性。类似 C/C++ 的条件编译，在执行go build时可传入一些选项，根据这个选项决定某些文件是否编译。wire工具只会处理有`wireinject`的文件，所以我们的`wire.go`文件要加上这个。生成的`wire_gen.go`是给我们来使用的，wire不需要处理，故有`!wireinject`。由于现在是两个文件，我们不能用`go run main.go`运行程序，可以用`go run .`运行。运行结果与之前的例子一模一样！


**使用前** VS **使用后**
```go
/*
// 使用wire前
func main() {
	message := NewMessage("hello world")
	greeter := NewGreeter(message)
	event := NewEvent(greeter)

	event.Start()
}*/

// 使用wire后
func main() {
	event := InitializeEvent("hello_world")

	event.Start()
}
```

在quickstart的例子中，`NewMessage`,`NewGreeter`,`NewEvent`都是`provider`，`wire_gen.go`中的`InitializeEvent`函数是`injector`，可以看到`injector`通过按依赖顺序调用`provider`来生成我们需要的对象`Event`。

上述示例在`wire.go`中定义了`injector`的函数签名，注意要在文件第一行加上
```go
// +build wireinject
...
```
用于告诉编译器无需编译该文件。在`injector`的签名定义函数中，通过调用`wire.Build`方法，指定用于生成依赖的`provider`:
```go
// InitializeEvent 声明injector的函数签名
func InitializeEvent(msg string) Event{
	wire.Build(NewEvent, NewGreeter, NewMessage) // <--- 传入provider函数
	return Event{}  //返回值没有实际意义，只需符合函数签名即可
}
```
## 错误
wire遵循 `fail-fast` 的原则，错误必须被处理。如果我们的注入器不返回错误，但构造器返回错误，wire工具会报错！

不是所有的构造操作都能成功，：
```go
// NewEvent Event构造函数 新增了错误返回
func NewEvent(g Greeter) (Event,error) {
	return Event{Greeter: g}, errors.New("error httprouter_test")
}
```
我们使创建随机失败，修改注入器`InitializeEvent()`的签名，增加error返回值：

```go
func InitializeEvent(msg string) (Event, error) {
  wire.Build(NewEvent, NewGreeter, NewMessage)
  return Event{}, nil
}
```
生成的代码，会将`NewEvent()`返回的错误，作为`InitializeEvent()`的返回值：

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

// Injectors from wire.go:

func InitializeEvent(msg string) (Event, error) {
	message := NewMessage(msg)
	greeter := NewGreeter(message)
	event, err := NewEvent(greeter)
	if err != nil {
		return Event{}, err
	}
	return event, nil
}
```