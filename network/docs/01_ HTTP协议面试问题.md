#  HTTP协议相关面试问题
## HTTP 基础知识
### 什么是HTTP协议？
#### 考察点
- 你是怎么理解HTTP协议的
- HTTP协议包含哪些内容
#### 回答关键词
##### HTTP是什么？ 
超文本传输协议，也就是 HyperText Transfer Protocol。
##### 能否详细解释「超文本传输协议」？ 进一步理解
回答这个问题，主要回答三个方面：
- 请求/响应报文具体组成
- 连接建立流程
- HTTP的特点
###### 请求/响应报文
我们先主要梳理下 **请求/响应报文** 的面试回答。

**首先谈谈请求报文的格式**：
1. 请求行。包含方法、URL、协议版本、CRLF(回车换行)
2. 请求首部。可以是零个或任意个，`key: value`方式
   1. Host: www.w3.org
   2. User-Agent: Mozilla/5.0
   3. 等等
3. CRLF(回车换行)
4. 报文主体。其是可选的，GET请求一般不带有主体，POST请求会有。
   
**然后谈谈响应报文的格式**：
1. 响应行。协议版本、状态码、状态码描述短语、CRLF(回车换行)
2. 响应首部。可以是零个或任意个，`key: value`方式
   1. Host: www.w3.org
   2. User-Agent: Mozilla/5.0
3. CRLF(回车换行)
4. 报文主体。
###  HTTP的请求方式有哪些？
请求/响应报文 引申出的面试问题

至少回答前四个
- GET: 获取资源
- PUT
- POST
- DELETE: 删除URI指定资源
- HEAD: 与GET的作用类似，唯一不同是HEAD方法不要求返回报文的主体；通常用于在不获取报文主体的情况下，取得响应的首部
- OPTIONS: 命令服务器返回它支持的HTTP方法列表 
- TRACE: 命令服务器返回请求本身。这样客户端就可以知道介于它和服务之间的其他服务器是如何处理请求的
- CONECT: 命令服务器与客户端建立一个网络连接，通常用于设置SSL隧道以及开启HTTPS功能。现在绝大部分浏览器都支持HTTPS
- PATCH

### 常见的HTTP状态码有哪些？
#### 考察点
- 状态码含义
- 一些状态码的区别
#### 回答
- 1xx:信息响应类，表示接收到请求并且继续处理
- 2xx:处理成功响应类，表示动作被成功接收、理解和接受
- 3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理
- 4xx:客户端错误，客户请求包含语法错误或者是不能正确执行
- 5xx:服务端错误，服务器不能正确执行一个正确的请求
### 说说301和302的区别？

- **301**: 表示永久重定向，说明请求的资源已经不存在了，需改用新的URL再次访问

- **302**: 表示临时重定向，说明请求的资源还在，但暂时需要另一个URL再次访问

301和302都会在响应头里使用字段 `Location`，指明后续要跳转的URL，浏览器就会自动重定向到新的URL
## GET与POST
### GET\POST的区别？
这个问题回答的少了太初级，毕竟是非常基础的问题，尽量有条理、有深度的回答。
#### 语义方面
**语义就是协议定义的规范** 
- `GET`请求**获取资源**，主要是**获取资源**，它需要遵从以下规范：安全的、幂等的、可缓存的
- `POST`请求是**处理资源**，非安全的、非幂等的、不可缓存的

安全、幂等、可缓存，正是RFC关于语义规范定义的一些描述
##### 安全性
安全性是指HTTP方法**只要求服务器提供信息**，但并不会对服务器的状态做任何修改，那么这个方法就是安全的

这些方法包括: GET、HEAD、OPTIONS、TRACE

与其相反的方法有： PUT、POST、DELETE
##### 幂等性
幂等性指同一个请求方法执行一次和执行多次的效果完全相同。

也就是说一个http方法在使用 **相同的数据**进行第二次、甚至多次调用的时候，**不会对服务器的状态造成任何改变**。

首先明白，所有的安全请求方法都是幂等。PUT、DELETE 虽不安全，但却是幂等的，因为它们在进行第二次调用时都不会改变服务器的状态。

对于PUT请求，服务器在执行第一个请求之后，URI指定的资源已经被更新或创建出来了，所以针对同一个资源第二次PUT请求只会执行服务器已经执行过的动作。

与此类似，虽然服务器对于同一个资源的第二次DELETE请求可能返回一个错误，但这个请求并不会改变服务器的状态.

相反，因为重复的POST请求是否会改变服务器的状态是由服务器决定的，所以POST方法既不是安全的，也不是幂等的

##### 可缓存性
可缓存性指请求是否可以被缓存. 比如GET\HEAD方法

一般在发起一个HTTP请求过程中，它在网络中的请求链路是很复杂的，可能中间经过了网关， 代li服务器等等，然后最终传递到server端。

这其中一些代li服务器可能会有缓存机制的，而这种缓存性是RFC官方文档定义的一种规范， 可以选择遵守或不遵守。

大多数情况下是遵守的，当代li服务器有缓存机制的情况下， GET请求是会被代li服务器缓存的， 这样我们在多次执行GET请求的时候， 得到的结果可能是已缓存的内容。

#### 参数设置方面
  -  `GET`参数是有长度限制的(2048字符)，它的请求参数是以 `?` 分割拼接到URL后面； 
  -  `POST`参数长度是无限制的，请求参数在Body里面。

## HTTP特性

## HTTP与HTTPS

## HTTP1.1\HTTP2\HTTP3演变
### HTTP 1.1
**回答关键点：**

- 长连接
- 管道网络传输，按请求的顺序返回相应，会引申出货队头阻塞问题
- 队头阻塞，

HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。

1. 长连接

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

短连接与长连接
2. 管道网络传输

HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。

管道网络传输
但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。

3. 队头阻塞

「请求 - 应答」的模式加剧了 HTTP 的性能问题。

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班的路上塞车。

队头阻塞
总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。

