# MySQL索引失效的底层原理

联合索引会失效的场景有：
- 最左前缀法则
- 大于号 '>'，右边的索引会失效
- 使用 `like`时，有些情况下索引也会失效 
## 多个键值的B+数


![](../../img/图3%20多个键值的B+树.png)

图中的细节请注意：
- 从左到右，a 的值是有顺序的：1, 1, 2, 2, 3, 3
  - a 相同的情况下，对应的 b 的值也是顺序的：(1,1)、 (1,2) 或 (3,1)、(3,2)
- 从左到右，b 的值是没有顺序的：1, 2, 1, 4, 1, 2


也就是说，(a,b)这个联合索引在B+树的排序是：
- 先排a的顺序
- 在a相等的情况下，再排b

## 实战验证

以下SQL会走索引吗？为什么？

**第一条：**
```sql
select * from table where a = 1 order by b; 
select * from table where a = 1 and b= 1;
```
答案：
> 会走索引。因为sql条件是先写的a，而a在B+树中是有序保存的。MySQL去查找时，根据二分查找先找到a字段的数据，
> 
> 而在a相等的情况下，b也是有序的，那么在a的基础上，同样也可以使用二分查找法找到b字段的数据。 
> 
> 该sql遵循最左前缀原则

**第二条：**

```sql
select * from table where b in (1,4);  
select * from table where b = 1;  
```

答案：

> 不会走索引。因为sql条件中并没有a字段，这就意味着并没有使用排序好的a，在没有a的情况下，b就是无序的。
> 
> 因为b有序的条件是在a相等的情况下，那么就无法使用二分查找来快速找到b字段的数据了，即用不到索引，就直接全表扫描了
> 
> 该sql不遵循最左前缀原则

**第三条：**

```sql
select * from table where a > 1001 and b = 1;
```
我们先找出 a > 1 的数据；

> (2,1), (2,4), (3,1), (3,2)

观察数据：a的位置是有序的，但是b的位置却是无序的，b无序不仅仅体现在叶子节点上，非叶子节点也是这样的

答案：
> 不会走索引。因为a的位置是有序的，但是b的位置却是无序的，也就无法使用二分查找法来找b字段的数据
> 
> 该sql不遵循最左前缀原则

**第三条：**

```sql
select * from table where a like %1%; // 任意位置包含1的数据
select * from table where a like %1;  // 以1结尾的数据
```

答案：
> 不会走索引。 `%1`中 1 为后缀； `%1%`中 1 为中缀。 B+树中叶子节点存储的数据是按数据前缀排序的
> 
> 除了按数字排序外，对于字母也是按26个英文字母从头到尾依次排序的。比如正确的存储顺序：： 'abc' -> 'aca' 
> 
> 上述两个sql中，并没有使用前缀来查找，这意味着对应的数据都是无序，也就无法使用二分查找法了。
> 
> 该sql不遵循最左前缀原则

补充：

- 这个最左前缀可以是联合索引的最左 N 个字段，也可以是**字符串**索引的最左 M 个字符。
