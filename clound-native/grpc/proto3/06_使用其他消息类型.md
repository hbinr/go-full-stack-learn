# 使用其他消息类型

您可以将其他消息类型用作字段类型。 

例如，假设您想在每条 SearchResponse 消息中包括结果消息。可以在同一.proto中定义结果消息类型，然后在SearchResponse中指定结果类型的字段：
```go
message SearchResponse {
  repeated Result results = 1;
}

message Result {
  string url = 1;
  string title = 2;
  repeated string snippets = 3;
}
```

## 导入定义

### 1.知识点
在上面的示例中，`Result` 消息类型与 `SearchResponse` 定义在同一文件中-如果要在另一个 .proto 文件中定义要用作字段类型的消息类型，该怎么办？

您可以通过导入其他 .proto 文件使用它们的定义。 要导入另一个.proto的定义，请在文件顶部添加一个import语句：
```go
import "myproject/other_protos.proto";
```

默认情况下，您只能使用直接导入的 .proto 文件中的定义。 但是，有时您可能需要将.proto文件移动到新位置。 

现在，您可以直接在原始位置放置一个虚拟 .proto 文件，而不是直接移动 .proto 文件并一次更改所有调用方。

通过使用 `import public` 将所有导入**转发到新位置**。 `import public` 依赖性会通过任意导入包含 `import public` 声明的 .proto 文件传递。 例如：
```go
// 这是新的proto
// All definitions are moved here
```

```go
// 这是旧的proto
// 这是所有客户端正在导入的包
import public "new.proto";
import "other.proto";

```

```go
// 客户端proto
import "old.proto";
// 现在你可以使用新旧两种包的proto定义了。
```



**import搜索路径：**

在使用protoc编译时，需要使用选项 `-I` 或 `--proto_path` 通知protoc去什么地方查找import的文件，如果不指定，protoc将会在当前目录(即调用protoc的路径)下查找。

### 2.案列实战

[详情请见](../code/demo_product/pbfile/)

有3个proto文件 `base_model.proto` `prod_model.proto`、`product.proto`文件内容如下：

**base_model.proto：**
```go
syntax = "proto3";

package model;

message BaseModel {
    int64 ID = 1;
}
```

**prod_model.proto：**
```go
syntax = "proto3";

package model;

option go_package = "go-full-stack-learn/clound-native/grpc/code/demo_product/pbfile";

message Product {
    int32 ProdID = 1;
    string ProdName = 2;
    float ProdPrice = 3;
}
```

**product.proto：**
```go
syntax = "proto3";

package product_service;

option go_package = "go-full-stack-learn/clound-native/grpc/code/demo_product/pbfile";

message ProdRequest {
  int32 prodID = 1;
}

service ProdService{
  rpc GetProdName (ProdRequest) returns (ProdResponse);
  rpc GetProdNameList(QueryRequest) returns(ProdListResponse);
}
```


`product.proto`中需要增加一个接口——返回商品信息，需要字段类型是`Product`。

需要在 `product.proto` 中 `import "prod_model.proto"`，注意是导入字符串格式， 如下所示： 
```go
syntax = "proto3";

package product_service;

// 引入 prod_model.proto 定义的内容
import public "prod_model.proto";

option go_package = "go-full-stack-learn/clound-native/grpc/code/demo_product/pbfile";

message ProdRequest {
  int32 prodID = 1;
}

service ProdService{
  rpc GetProdName (ProdRequest) returns (ProdResponse);
  // 新增获取商品信息接口  
  rpc GetProdInfo(ProdRequest) returns(model.Product); // 需要加上包名 model
}
```

如果还想使用 `base_model.proto` 中的 `BaseModel` ， 你不能因为 product.proto 引用了 prod_model.proto， prod_model.proto又引用了 base_model.proto，就可以直接在 product.proto 中使用 base_model.proto 的对象，这里不具有传递性， base_model.proto 在 product.proto 中依旧不可见。

有两种方法可以解决：
  
- 在 product.proto 中 import "base_model.proto";
- 在 product.proto 中 import public "prod_model.proto";  推荐这种方式
  
**需要提醒一下：**

> 在使用Goland编写 proto 文件时，尽管已经引入了插件 **Protocol Buffer Editor**，但是 import 其他proto的时候会报红，但是不影响正常使用。