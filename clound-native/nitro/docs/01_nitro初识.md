# nitro初识

`Nitro`（前身：Go-Micro）是一种非常快速的分布式应用程序开发框架。

## 总览
`Nitro`提供了分布式应用程序开发的核心要求，包括RPC和事件驱动的通信。 `Nitro`模型是具有可插拔体系结构的内存默认值。 进行纯内存开发，并根据需要进行交换以进行多进程或多主机。

## 特性

`Nitro`提取了分布式系统的详细信息。 这是主要功能：
- Authentication（身份认证） `Auth`内置为头等公民。 身份验证和授权通过为每个服务提供身份和证书来实现安全的零信任网络。 这另外包括基于规则的访问控制。
- Dynamic Config（动态配置）从任何位置加载和热重新加载动态配置。`config`接口提供了一种从任何来源（例如`env vars`，`file`等）加载应用程序级别`config`的方法。 您可以合并源，甚至定义后备。
- Data Storage（数据存储）定义了一个简单的数据存储接口，用于读取，写入和删除记录。 默认情况下，它包括对内存，文件和`CockroachDB`的支持。 状态和持久性已成为原型之外的核心要求，`Nitro`希望将其构建到框架中。
- Service Discovery（服务发现）自动服务注册和名称解析。 服务发现是微服务开发的核心。 当服务A需要与服务B通话时，它需要该服务的位置。 默认发现机制是多播`DNS`（`mdns`），一种零配置系统。
- Load Balancing（负载平衡）基于服务发现的客户端负载平衡。 一旦获得了任意数量的服务实例的地址，我们现在需要一种方法来确定要路由到的节点。 我们使用随机散列负载平衡来提供服务之间的平均分配，并在出现问题时重试其他节点。
- Message Encoding（消息编码） 基于内容类型的动态消息编码。 客户端和服务器将使用编解码器以及`content-type`来为您无缝编码和解码`Go`类型。 各种消息可以被编码并从不同的客户端发送。 客户端和服务器默认情况下会处理此问题。 默认情况下，这包括`protobuf`和`json`。
- RPC Communication（RPC通信）具有双向流支持的同步请求/响应。 我们为同步通信提供了一个抽象。 对服务的请求将被自动解决，负载均衡，拨号和流式传输。
- Async Messaging（异步消息传递）`PubSub`内置为异步通信和事件驱动的体系结构的一等公民。 事件通知是微服务开发中的核心模式。 默认消息传递系统是HTTP事件消息代理。
- Synchronization（同步）分布式系统通常以最终一致的方式构建。 支持分布式锁定和`leadership`作为同步接口。 使用最终一致的数据库或计划时，请使用`Sync`接口。
- Pluggable Interfaces（可插拔接口） `Nitro`为每个包装使用Go接口。 因此，这些接口是可插拔的，并允许`Nitro`与运行时无关。 您可以插入任何基础技术。 在`github.com/asim/nitro-plugins`中找到外部第三方（非stdlib）插件。
  
## API
见[go-nitro.dev/docs/v3](https://go-nitro.dev/docs/v3/)
## Go Micro发生了什么？

`Go Micro`现在已重命名为`Nitro`。 `Go Micro`不再是个人项目。 因此不再生活在github.com/micro组织之下。 该公司现在正在加倍使用Micro本身，并引入了所需的接口以将服务器，框架和CLI整合为一个工具。 `Go Micro`现在不再由公司维护。 然而，即使作为个人回购协议，它也继续造成混乱。 因此，我们将其重命名为`Nitro`。

## 为什么许可证从Apache 2.0更改为Polyform Noncommercial
`Go Micro`在整个生命周期中都是一项单独的维护工作。 它可以创建一家名为Micro Services，Inc.的公司，该公司现在专注于微服务即服务，并将此处的所有接口合并到该项目的服务库中。 在大多数情况下，`Go Micro`都没有资金，并且在某些方面受到赞赏。 在3.0版中，回到6年来的个人项目中，我做出了艰难的决定，要重新许可为非商业项目。 对于任何商业应用程序，我正在寻找github赞助，以便我可以将这些资金用于维护和支持工作。

## 所有的插件在哪里？
这些插件现在位于[github.com/asim/nitro-plugins](https://github.com/asim/nitro-plugins)中。 这是为了将`Go Micro`的整体大小和范围缩小到纯粹的一组接口和标准库实现。 `Go Plugins`已获得Apache 2.0许可，但依赖`Nitro`接口，因此再次只能在没有商业许可的情况下用于非商业环境。

## Nitro的新方向是什么？
`Nitro`现在将专注于使用Go标准库进行分布式应用程序开发。继续进行分布式系统定义抽象，但是只会在没有外部依赖的情况下进行定义。所有这些外部依赖项都将存在于`Nitro`插件中。 中。通过这种方式，可以以最小的增量为内存或资源占用量低的各种新应用程序选择`Nitro`。假设有一些地方希望使用分布式应用程序，就像嵌入式系统或Web程序集，单核，和相关目标一样，这些地方会受益于将这些应用程序定义为此类用途的框架。


## 顶级服务定义在哪里？
顶级服务定义已移至`service package`。 `Nitro`exploded 是因为它提供的接口。。 虽然最初是一个小型库，但软件包的增加意味着顶级不能真正提供所有内容的完整范围。 目前尚不清楚是否应返回顶级定义。

## 默认的初始化接口在哪里？
默认设置消失了。 事实证明，这是一种不良的设计模式，这意味着需要对接口进行定义，使其与接口并存。 随着时间的流逝，它变得非常复杂，切换出来意味着您已经在其中进行了预初始化的实现，并且无法进行大量清理。 因此，删除它似乎是一种更干净的接口设计和软件包模块化方法。
## `cmd package`、`flag parsing`等在哪里？
这些也消失了。 老实说，这段代码的复杂性令人震惊。 命令软件包必须对如何加载插件做出假设，因为每个软件包都依赖于其他软件包。 整个系统变得无法维护，即使在Micro中，我们也希望将其报废以简化初始化。 标志解析(flag parsing)，插件加载( plugin loading)等全都不再支持用户自定义。 我们发现，大多数插件需要比硬编码值提供更多的初始化。 由于这个原因，我们可能会考虑使用[github.com/google/wire](https://github.com/google/wire)作为更好的选择。



## Nitro和Micro现在有何不同？
`Micro`是用于云原生开发的平台。 包括服务器，框架和多语言客户端的完整体验。 除此之外，它还包括环境，多租户和更多功能，这使其成为托管的微服务即服务产品。 这是一个完整的平台。

`Nitro`不仅仅是一个用于分布式应用程序开发的可插入框架，现在又是我和可能仍在商业或非商业用途中使用的其他人维护的纯个人项目。 它具有感性的价值，我想为个人项目进行诸如与边缘，物联网，嵌入式系统，`p2p`，`web assembly`等相关的事情。

## 我使用Go Micro来构建微服务。 我现在应该怎么办？
老实说，您应该仔细研究一下Micro，然后考虑[m3o.com](https://m3o.com/)上的托管产品，该产品最初是云上的免费开发环境。 Micro会继续解决您的许多顾虑和要求，甚至更多。 您很有可能需要管理指标，跟踪，日志记录以及需要插入的许多其他样板文件。Micro现在将采用此完整的平台故事方法，并在此过程中为您提供帮助，例如，您可能在具有以下功能的主要云提供商上运行托管`kubernetes`等许多其他事情。 我们是作为公司和平台团队为您这样做的。

## 我想为我的公司使用Go Micro版本2.0。 我还能做吗？
是。 Go Micro 2.0仍然是Apache 2.0许可的，这意味着您仍然可以自由使用它来进行以前使用的所有操作。 如果您是新用户，则可以执行相同操作。 这些东西都在使用go模块，因此您导入的路径与以前一样只是`github.com/micro/go-micro/v2`。 因为GitHub处理重定向，所以它不会中断。 如果愿意，请继续使用它，但是我自己对2.0的支持现在已经终止。 找时间的时候，我将重点介绍3.0方面的一些技巧。